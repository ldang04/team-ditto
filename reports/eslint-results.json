[{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/app.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/config/keywords.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/config/logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/config/supabaseClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/controllers/ClientController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/controllers/ContentController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/controllers/HealthController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/controllers/ImageGenerationController.ts","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":246,"column":21,"nodeType":"MemberExpression","endLine":246,"endColumn":39}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * controllers/ImageGenerationController.ts\n *\n * Handles image generation using Vertex AI Imagen with RAG and computational analysis.\n */\n\nimport { Request, Response } from \"express\";\nimport { ContentModel } from \"../models/ContentModel\";\nimport { EmbeddingService } from \"../services/EmbeddingService\";\nimport {\n  GeneratedImage,\n  ImageGenerationService,\n} from \"../services/ImageGenerationService\";\nimport { RAGService } from \"../services/RAGService\";\nimport { ThemeAnalysisService } from \"../services/ThemeAnalysisService\";\nimport { PromptEnhancementService } from \"../services/PromptEnhancementService\";\nimport { StorageService } from \"../services/StorageService\";\nimport { ProjectThemeService } from \"../services/ProjectThemeService\";\nimport { ServiceResponse } from \"../types/serviceResponse\";\nimport { StatusCodes } from \"http-status-codes\";\nimport { handleServiceResponse } from \"../utils/httpHandlers\";\nimport logger from \"../config/logger\";\nimport { QualityScoringService } from \"../services/QualityScoringService\";\n\nexport const ImageGenerationController = {\n  /**\n   * HTTP handler to generate images for a project prompt.\n   *\n   * Behavior:\n   * - Validates inputs (variant count and aspect ratio).\n   * - Performs RAG retrieval to gather contextual examples.\n   * - Analyzes the project's theme to extract colors/styles/mood.\n   * - Enhances the prompt using RAG + theme signals, then composes a\n   *   branded prompt and negativePrompt.\n   * - Calls the image generation service, persists images to storage and DB,\n   *   generates embeddings for saved content, and returns metrics.\n   *\n   * Responses:\n   * - 201 Created with generation metadata on success\n   * - 400 Bad Request for invalid inputs\n   * - 404 Not Found when project/theme missing\n   * - 500 Internal Server Error for unexpected failures\n   */\n  async generate(req: Request, res: Response) {\n    try {\n      logger.info(`${req.method} ${req.url} ${JSON.stringify(req.body)} `);\n\n      // Parse and validate request\n      const {\n        project_id,\n        prompt,\n        style_preferences = {},\n        target_audience = \"general\",\n        variantCount = 3,\n        aspectRatio = \"1:1\",\n      } = req.body;\n\n      // Validate variantCount: must be an integer between 0 and 10.\n      const requestedVariantCount = Number(variantCount);\n      if (\n        Number.isNaN(requestedVariantCount) ||\n        !Number.isInteger(requestedVariantCount) ||\n        requestedVariantCount < 0 ||\n        requestedVariantCount > 10\n      ) {\n        const serviceResponse = ServiceResponse.failure(\n          null,\n          \"Invalid variantCount: must be an integer between 0 and 10\",\n          StatusCodes.BAD_REQUEST\n        );\n        return handleServiceResponse(serviceResponse, res);\n      }\n      const validatedVariantCount = requestedVariantCount;\n\n      // Validate aspectRatio: ensure it is one of the supported ratios.\n      const allowedAspectRatios = [\"1:1\", \"16:9\", \"9:16\", \"4:5\", \"3:2\"];\n      const requestedAspectRatio = String(aspectRatio || \"1:1\");\n      if (!allowedAspectRatios.includes(requestedAspectRatio)) {\n        const serviceResponse = ServiceResponse.failure(\n          null,\n          `Invalid aspectRatio: must be one of ${allowedAspectRatios.join(\n            \", \"\n          )}`,\n          StatusCodes.BAD_REQUEST\n        );\n        return handleServiceResponse(serviceResponse, res);\n      }\n      const validatedAspectRatio = requestedAspectRatio;\n\n      // Validation: either project_id or prompt must exist\n      if (!project_id || !prompt) {\n        const serviceResponse = ServiceResponse.failure(\n          null,\n          \"Missing required fields: project_id and prompt\",\n          StatusCodes.BAD_REQUEST\n        );\n        return handleServiceResponse(serviceResponse, res);\n      }\n\n      // Fetch project and theme\n      const projectThemeData = await ProjectThemeService.getProjectAndTheme(\n        project_id\n      );\n\n      if (!projectThemeData) {\n        const serviceResponse = ServiceResponse.failure(\n          null,\n          \"Project or theme not found\",\n          StatusCodes.NOT_FOUND\n        );\n        return handleServiceResponse(serviceResponse, res);\n      }\n\n      const { project, theme } = projectThemeData;\n\n      logger.info(\n        `ImageGenerationController: Starting generation for project ${project_id}`\n      );\n\n      // STEP 1: Perform RAG retrieval\n      logger.info(\"STEP 1: RAG retrieval\");\n      const ragContext = await RAGService.performRAG(project_id, prompt, theme);\n\n      // STEP 2: Analyze theme\n      logger.info(\"STEP 2: Theme analysis\");\n      const themeAnalysis =\n        theme.analysis ?? ThemeAnalysisService.analyzeTheme(theme);\n\n      // STEP 3: Enhance prompt with RAG\n      logger.info(\"STEP 3: Prompt enhancement\");\n      const enhancedPrompt = PromptEnhancementService.enhancePromtWithRAG(\n        prompt,\n        ragContext,\n        themeAnalysis\n      );\n\n      // STEP 4: Build branded prompt\n      // Compose the final prompt that includes branding context (project name,\n      // description, audience) and also produce a negativePrompt to avoid\n      // undesired artifacts during generation.\n      logger.info(\"STEP 4: Building branded prompt\");\n      const { prompt: brandedPrompt, negativePrompt } =\n        PromptEnhancementService.buildBrandedPrompt({\n          userPrompt: enhancedPrompt,\n          projectName: project.name,\n          projectDescription: project.description,\n          themeInspirations: theme.inspirations,\n          stylePreferences: style_preferences,\n          targetAudience: target_audience,\n        });\n\n      // STEP 5: Generate images\n      logger.info(\"STEP 5: Generating images\");\n      const generatedImages = await ImageGenerationService.generateImages({\n        prompt: brandedPrompt,\n        negativePrompt: negativePrompt,\n        aspectRatio: validatedAspectRatio as any,\n        numberOfImages: validatedVariantCount,\n        guidanceScale: 15,\n      });\n\n      // STEP 6: Save to storage and database\n      logger.info(\"STEP 6: Saving to storage\");\n      const savedVariants = await ImageGenerationController.saveGeneratedImages(\n        generatedImages,\n        project_id,\n        prompt,\n        brandedPrompt\n      );\n\n      if (savedVariants.length === 0 && validatedVariantCount !== 0) {\n        throw new Error(\"Failed to save any image variants\");\n      }\n\n      // STEP 7: Calculate quality scores\n      logger.info(\"STEP 7: Quality calculations\");\n      const promptQuality = QualityScoringService.scorePromptQuality(\n        brandedPrompt,\n        theme.tags\n      );\n      const predictedQuality = PromptEnhancementService.scoreRagQuality(\n        themeAnalysis,\n        ragContext,\n        brandedPrompt.length\n      );\n\n      // Build response with metrics\n      const serviceResponse = ServiceResponse.success(\n        {\n          variants: savedVariants,\n          project_id,\n          media_type: \"image\",\n          variant_count: savedVariants.length,\n          computation_metrics: {\n            rag_similarity: ragContext.avgSimilarity,\n            theme_analysis: themeAnalysis,\n            prompt_quality: promptQuality,\n            predicted_quality: predictedQuality,\n            rag_context_items: ragContext.relevantContents.length,\n          },\n          timestamp: new Date().toISOString(),\n        },\n        \"Images generated successfully with RAG and computational analysis\",\n        StatusCodes.CREATED\n      );\n\n      return handleServiceResponse(serviceResponse, res);\n    } catch (error: any) {\n      logger.error(\"ImageGenerationController: Error in generate:\", error);\n      const serviceResponse = ServiceResponse.failure(\n        error,\n        \"Image generation failed\"\n      );\n      return handleServiceResponse(serviceResponse, res);\n    }\n  },\n\n  /**\n   * Persist generated images: create DB records, upload files, update rows,\n   * and generate embeddings for each saved image.\n   *\n   * Steps per image:\n   * 1. Create a placeholder content record in the DB (media_url empty).\n   * 2. Upload image bytes to storage and obtain a public URL.\n   * 3. Update the content record with the final `media_url`.\n   * 4. Generate and store embeddings for the saved content.\n   * 5. Accumulate metadata for the response (content id, URL, seed, prompts).\n   *\n   * The function returns an array of saved variant metadata; failures for\n   * individual variants are logged and skipped so the caller can still receive\n   * successfully persisted images.\n   */\n  async saveGeneratedImages(\n    generatedImages: GeneratedImage[],\n    project_id: string,\n    prompt: string,\n    enhancedPrompt: string\n  ): Promise<any[]> {\n    logger.info(\n      `ImageGenerationController: Save generated images in db and storage`\n    );\n    const savedVariants: any[] = [];\n\n    // Iterate through each generated image and persist it.\n    for (let i = 0; i < generatedImages.length; i++) {\n      const image = generatedImages[i];\n\n      try {\n        // 1) Create content record placeholder (media_url empty until upload completes).\n        const { data: contentData, error: contentError } =\n          await ContentModel.create({\n            project_id,\n            media_type: \"image\",\n            media_url: \"\",\n            text_content: image.imageData,\n            enhanced_prompt: enhancedPrompt,\n            prompt,\n          });\n\n        // If DB insert failed, skip this variant and log the error.\n        if (contentError || !contentData) {\n          logger.error(`Failed to create content record ${i}:`, contentError);\n          continue;\n        }\n\n        // 2) Generate any required image embeddings and persist them.\n        //    This is optional depending on EmbeddingService implementation.\n        await EmbeddingService.generateAndStoreImage(\n          contentData.id!,\n          image.imageData\n        ).catch((error) =>\n          logger.error(`Failed to save embedding for record ${i}:`, error)\n        );\n\n        // 3) Upload image bytes to storage and get a final URL.\n        const imageUrl = await StorageService.uploadImage(\n          image.imageData,\n          image.mimeType,\n          project_id,\n          contentData.id!\n        );\n\n        // 4) Update the DB record with the final media URL.\n        await ContentModel.updateMediaUrl(contentData.id!, imageUrl);\n\n        // 5) Add to the response payload collected for successful variants.\n        savedVariants.push({\n          content_id: contentData.id,\n          image_url: imageUrl,\n          prompt: prompt,\n          enhancedPrompt,\n          seed: image.seed,\n        });\n\n        logger.info(\n          `ImageGenerationController: Saved image variant ${i + 1}/${\n            generatedImages.length\n          }`\n        );\n      } catch (error) {\n        logger.error(\n          `ImageGenerationController: Failed to save variant ${i}:`,\n          error\n        );\n        continue;\n      }\n    }\n\n    return savedVariants;\n  },\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/controllers/ProjectController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/controllers/TextGenerationController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/controllers/ThemeController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/controllers/ValidationController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/middleware/auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/models/ApiKeyModel.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/models/ClientModel.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/models/ContentModel.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/models/EmbeddingsModel.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/models/ProjectModel.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/models/ThemeModel.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/routes/clientRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/routes/contentRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/routes/imageRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/routes/projectRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/routes/textRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/routes/themeRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/routes/validationRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/services/EmbeddingService.ts","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":249,"column":21,"nodeType":"MemberExpression","endLine":249,"endColumn":28},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":249,"column":31,"nodeType":"MemberExpression","endLine":249,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":251,"column":15,"nodeType":"MemberExpression","endLine":251,"endColumn":22},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":251,"column":25,"nodeType":"MemberExpression","endLine":251,"endColumn":32},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":252,"column":15,"nodeType":"MemberExpression","endLine":252,"endColumn":22},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":252,"column":25,"nodeType":"MemberExpression","endLine":252,"endColumn":32},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":292,"column":7,"nodeType":"MemberExpression","endLine":292,"endColumn":26},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":300,"column":7,"nodeType":"MemberExpression","endLine":300,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * EmbeddingService.ts\n *\n * Handles all text embedding operations using Vertex AI Text Embeddings API\n * Model: text-embedding-004 (768 dimensions)\n */\n\nimport { GoogleAuth } from \"google-auth-library\";\nimport { EmbeddingsModel } from \"../models/EmbeddingsModel\";\nimport logger from \"../config/logger\";\n\nexport class EmbeddingService {\n  private static auth: GoogleAuth;\n  private static projectId: string;\n\n  /**\n   * Initialize the service with GCP credentials\n   */\n  static initialize() {\n    this.auth = new GoogleAuth({\n      scopes: \"https://www.googleapis.com/auth/cloud-platform\",\n    });\n    this.projectId = process.env.GCP_PROJECT_ID || \"\";\n    logger.info(\"EmbeddingService: Initialized the service\");\n  }\n\n  /**\n   * Generate an embedding for document storage.\n   *\n   * Sends the provided `text` to the Vertex AI Text Embeddings API\n   * (model: `text-embedding-004`) with task type `RETRIEVAL_DOCUMENT` and\n   * returns the resulting numeric embedding vector.\n   *\n   * If Vertex AI does not return an embedding or an error occurs while\n   * requesting the remote API, a deterministic local fallback embedding is\n   * generated via `generateFallbackEmbedding` to ensure the method always\n   * returns a 768-dimensional vector.\n   *\n   * @param text - The document text to embed.\n   * @returns A Promise resolving to a 768-dimensional numeric array\n   * representing the embedding vector.\n   */\n  static async generateDocumentEmbedding(text: string): Promise<number[]> {\n    try {\n      logger.info(`EmbeddingService: generateDocumentEmbedding for ${text}`);\n      const client = await this.auth.getClient();\n      const url = `https://us-central1-aiplatform.googleapis.com/v1/projects/${this.projectId}/locations/us-central1/publishers/google/models/text-embedding-004:predict`;\n\n      const response = await client.request({\n        url,\n        method: \"POST\",\n        data: {\n          instances: [\n            {\n              content: text,\n              task_type: \"RETRIEVAL_DOCUMENT\",\n            },\n          ],\n        },\n      });\n\n      const embedding =\n        (response.data as any)?.predictions?.[0]?.embeddings?.values || [];\n\n      if (embedding.length === 0) {\n        logger.warn(\"No embedding returned from Vertex AI, using fallback\");\n        return this.generateFallbackEmbedding(text);\n      }\n\n      return embedding;\n    } catch (error) {\n      logger.error(\"Failed to generate Vertex AI embedding:\", error);\n      return this.generateFallbackEmbedding(text);\n    }\n  }\n\n  /**\n   * Generate an embedding optimized for search queries.\n   *\n   * Sends the provided `text` to the Vertex AI Text Embeddings API\n   * (model: `text-embedding-004`) with task type `RETRIEVAL_QUERY` and\n   * returns the resulting numeric embedding vector suitable for retrieval\n   * and semantic search.\n   *\n   * If Vertex AI does not return an embedding or an error occurs while\n   * requesting the remote API, a deterministic local fallback embedding is\n   * generated via `generateFallbackEmbedding` to ensure the method always\n   * returns a 768-dimensional vector.\n   *\n   * @param text - The query text to embed.\n   * @returns A Promise resolving to a 768-dimensional numeric array\n   * representing the embedding vector.\n   */\n  static async generateQueryEmbedding(text: string): Promise<number[]> {\n    try {\n      logger.info(`EmbeddingService: generateQueryEmbedding for ${text}`);\n      const client = await this.auth.getClient();\n      const url = `https://us-central1-aiplatform.googleapis.com/v1/projects/${this.projectId}/locations/us-central1/publishers/google/models/text-embedding-004:predict`;\n\n      const response = await client.request({\n        url,\n        method: \"POST\",\n        data: {\n          instances: [\n            {\n              content: text,\n              task_type: \"RETRIEVAL_QUERY\",\n            },\n          ],\n        },\n      });\n\n      const embedding =\n        (response.data as any)?.predictions?.[0]?.embeddings?.values || [];\n\n      if (embedding.length === 0) {\n        logger.warn(\"No embedding returned from Vertex AI, using fallback\");\n        return this.generateFallbackEmbedding(text);\n      }\n\n      return embedding;\n    } catch (error) {\n      logger.error(\"Failed to generate query embedding:\", error);\n      return this.generateFallbackEmbedding(text);\n    }\n  }\n\n  /**\n   * Generate an embedding for image data (base64).\n   *\n   * Uses an image-capable embedding endpoint if available; otherwise falls\n   * back to the existing deterministic text-based fallback.\n   *\n   * @param imageBase64 - Base64-encoded image bytes.\n   * @returns A Promise resolving to a 768-dimensional numeric array.\n   */\n  static async generateImageEmbedding(imageBase64: string): Promise<number[]> {\n    try {\n      logger.info(`EmbeddingService: generateImageEmbedding`);\n      const client = await this.auth.getClient();\n      const url = `https://us-central1-aiplatform.googleapis.com/v1/projects/${this.projectId}/locations/us-central1/publishers/google/models/multimodalembedding@001:predict`;\n\n      const response = await client.request({\n        url,\n        method: \"POST\",\n        data: {\n          instances: [\n            {\n              image: {\n                bytesBase64Encoded: imageBase64,\n              },\n            },\n          ],\n        },\n      });\n\n      const embedding =\n        (response.data as any)?.predictions?.[0]?.imageEmbedding || [];\n\n      if (embedding.length === 0) {\n        logger.warn(\"No embedding returned from Vertex AI, using fallback\");\n        return this.generateFallbackEmbedding(imageBase64);\n      }\n\n      return embedding;\n    } catch (error) {\n      logger.error(\"Failed to generate image embedding:\", error);\n      return this.generateFallbackEmbedding(imageBase64);\n    }\n  }\n\n  /**\n   * Generate an embedding for the provided `text` and persist it.\n   *\n   * Errors encountered while storing the embedding are logged\n   *\n   * @param contentId - The external identifier for the content being stored.\n   * @param text - The text content to embed and store.\n   * @returns A Promise that resolves to the generated 768-dimensional\n   * embedding vector.\n   */\n  static async generateAndStoreText(\n    contentId: string,\n    text: string\n  ): Promise<number[]> {\n    logger.info(\n      `EmbeddingService: generateAndStoreText for ${contentId}, ${text}`\n    );\n    const embedding = await this.generateDocumentEmbedding(text);\n\n    try {\n      await EmbeddingsModel.create({\n        content_id: contentId,\n        embedding: embedding,\n        text_content: text,\n        media_type: \"text\",\n      });\n    } catch (error) {\n      logger.error(\"Failed to store text embedding:\", error);\n    }\n\n    return embedding;\n  }\n\n  /**\n   * Generate an embedding for the provided `image` and persist it.\n   *\n   * Errors encountered while storing the embedding are logged\n   *\n   * @param contentId - The external identifier for the content being stored.\n   * @param imageBase64 - The encoded image to embed and store.\n   * @returns A Promise that resolves to the generated 768-dimensional\n   * embedding vector.\n   */\n  static async generateAndStoreImage(\n    contentId: string,\n    imageBase64: string\n  ): Promise<number[]> {\n    logger.info(`EmbeddingService: generateAndStoreImage for ${contentId}`);\n    const embedding = await this.generateImageEmbedding(imageBase64);\n\n    try {\n      await EmbeddingsModel.create({\n        content_id: contentId,\n        embedding: embedding,\n        text_content: imageBase64,\n        media_type: \"image\",\n      });\n    } catch (error) {\n      logger.error(\"Failed to store image embedding:\", error);\n    }\n\n    return embedding;\n  }\n\n  /** Calculate cosine similarity between two vectors. */\n  static cosineSimilarity(vecA: number[], vecB: number[]): number {\n    // Ensure vectors are same length and non-empty\n    if (vecA.length !== vecB.length || vecA.length === 0) return 0;\n\n    // Accumulators for dot product and squared magnitudes\n    let dotProduct = 0;\n    let magA = 0;\n    let magB = 0;\n\n    // Sum pairwise products and squared values\n    for (let i = 0; i < vecA.length; i++) {\n      // contribution to dot product\n      dotProduct += vecA[i] * vecB[i];\n      // accumulate squared values for magnitudes\n      magA += vecA[i] * vecA[i];\n      magB += vecB[i] * vecB[i];\n    }\n\n    // Convert squared magnitudes to magnitudes\n    magA = Math.sqrt(magA);\n    magB = Math.sqrt(magB);\n\n    // If either vector has zero magnitude, similarity is undefined -> return 0\n    if (magA === 0 || magB === 0) return 0;\n\n    // Cosine similarity = dot(A,B) / (|A| * |B|)\n    return dotProduct / (magA * magB);\n  }\n\n  /**\n   * Generate a deterministic fallback embedding.\n   *\n   * Produces a 768-dimensional vector derived from simple text features\n   * (word hashes, character n-grams, and basic text statistics). The\n   * resulting vector is normalized so it can be used as a drop-in substitute\n   * for Vertex AI embeddings when the remote service is unavailable.\n   *\n   * @param text - Input text to convert into an embedding.\n   * @returns A 768-dimensional normalized numeric array.\n   */\n  private static generateFallbackEmbedding(text: string): number[] {\n    // Target embedding dimensionality to match Vertex AI model\n    const dimensions = 768; // Match Vertex AI text-embedding-004\n    const embedding = new Array(dimensions).fill(0);\n\n    // Simple normalization and tokenization\n    const normalized = text.toLowerCase().trim();\n    const words = normalized.split(/\\s+/);\n    const chars = normalized.split(\"\");\n\n    // Feature 1: Word-based features — boost positions based on hashed word\n    // earlier words contribute more (1 / (idx + 1))\n    words.forEach((word, idx) => {\n      const hash = this.hashString(word);\n      const position = hash % dimensions;\n      embedding[position] += 1 / (idx + 1);\n    });\n\n    // Feature 2: Character n-grams — add small weights for trigrams\n    for (let i = 0; i < chars.length - 2; i++) {\n      const trigram = chars.slice(i, i + 3).join(\"\");\n      const hash = this.hashString(trigram);\n      const position = hash % dimensions;\n      embedding[position] += 0.5;\n    }\n\n    // Feature 3: Simple text statistics placed into reserved positions\n    embedding[0] = words.length / 100; // relative word count\n    embedding[1] = chars.length / 1000; // relative character count\n    embedding[2] = (text.match(/[.!?]/g) || []).length / 10; // sentence-ish count\n\n    // Normalize the vector to unit length\n    const magnitude = Math.sqrt(\n      embedding.reduce((sum, val) => sum + val * val, 0)\n    );\n    return embedding.map((val) => (magnitude > 0 ? val / magnitude : 0));\n  }\n\n  /**\n   * Deterministic hash function used by the fallback embedding generator.\n   *\n   * @param str - Input string to hash.\n   * @returns A non-negative integer hash value.\n   */\n  private static hashString(str: string): number {\n    // Starting accumulator\n    let hash = 0;\n\n    // Mix each character into the hash using a common bitwise pattern\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      // shift left 5 (multiply by 32), subtract previous hash, add char\n      hash = (hash << 5) - hash + char;\n      // Force to 32-bit integer to keep behavior consistent across runtimes\n      hash = hash & hash;\n    }\n\n    // Return absolute value to ensure non-negative bucket indices\n    return Math.abs(hash);\n  }\n}\n\n// Initialize on import\nEmbeddingService.initialize();\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/services/ImageGenerationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/services/ProjectThemeService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/services/PromptEnhancementService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/services/QualityScoringService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/services/RAGService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/services/StorageService.ts","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Function Call Object Injection Sink","line":155,"column":9,"nodeType":"MemberExpression","endLine":155,"endColumn":26},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":213,"column":12,"nodeType":"MemberExpression","endLine":213,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * services/StorageService.ts\n *\n * Handles file storage operations with Supabase Storage.\n * Manages image uploads, retrieval, and URL generation for generated content.\n */\n\nimport { supabase } from \"../config/supabaseClient\";\nimport logger from \"../config/logger\";\nimport { randomBytes } from \"crypto\";\n\nexport class StorageService {\n  private static readonly BUCKET_NAME = \"content-images\";\n  private static readonly MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB\n\n  /**\n   * Initialize storage bucket (ensure it exists)\n   * This should be called on app startup\n   */\n  static async initialize(): Promise<void> {\n    try {\n      // Check if bucket exists\n      const { data: buckets, error: listError } =\n        await supabase.storage.listBuckets();\n\n      if (listError) {\n        logger.error(\"StorageService: Error listing buckets:\", listError);\n        return;\n      }\n\n      const bucketExists = buckets?.some((b) => b.name === this.BUCKET_NAME);\n\n      if (!bucketExists) {\n        logger.info(\n          `StorageService: Bucket \"${this.BUCKET_NAME}\" does not exist. Creating...`\n        );\n\n        const { error: createError } = await supabase.storage.createBucket(\n          this.BUCKET_NAME,\n          {\n            public: true, // Images are public for content generation use\n            fileSizeLimit: this.MAX_FILE_SIZE,\n            allowedMimeTypes: [\n              \"image/png\",\n              \"image/jpeg\",\n              \"image/jpg\",\n              \"image/webp\",\n            ],\n          }\n        );\n\n        if (createError) {\n          logger.error(\"StorageService: Error creating bucket:\", createError);\n        } else {\n          logger.info(\n            `StorageService: Bucket \"${this.BUCKET_NAME}\" created successfully`\n          );\n        }\n      } else {\n        logger.info(\n          `StorageService: Bucket \"${this.BUCKET_NAME}\" already exists`\n        );\n      }\n    } catch (error) {\n      logger.error(\"StorageService: Initialization error:\", error);\n    }\n  }\n\n  /**\n   * Upload an image to Supabase Storage\n   * @param imageData - Base64 encoded image data\n   * @param mimeType - MIME type of the image (e.g., 'image/png')\n   * @param projectId - Project ID for organizing files\n   * @param contentId - Content ID for file naming\n   * @returns Public URL of the uploaded image\n   */\n  static async uploadImage(\n    imageData: string,\n    mimeType: string,\n    projectId: string,\n    contentId: string\n  ): Promise<string> {\n    try {\n      logger.info(`StorageService: Uploading image for content ${contentId}`);\n\n      // Convert base64 to buffer\n      const buffer = Buffer.from(imageData, \"base64\");\n\n      // Validate file size\n      if (buffer.length > this.MAX_FILE_SIZE) {\n        throw new Error(\n          `Image size (${buffer.length} bytes) exceeds maximum allowed size (${this.MAX_FILE_SIZE} bytes)`\n        );\n      }\n\n      // Generate unique filename\n      const fileExtension = this.getFileExtension(mimeType);\n      const randomSuffix = randomBytes(8).toString(\"hex\");\n      const fileName = `${projectId}/${contentId}_${randomSuffix}.${fileExtension}`;\n\n      // Upload to Supabase Storage\n      const { error } = await supabase.storage\n        .from(this.BUCKET_NAME)\n        .upload(fileName, buffer, {\n          contentType: mimeType,\n          upsert: false, // Don't overwrite existing files\n        });\n\n      if (error) {\n        logger.error(\"StorageService: Upload error:\", error);\n        throw new Error(`Failed to upload image: ${error.message}`);\n      }\n\n      // Get public URL\n      const { data: urlData } = supabase.storage\n        .from(this.BUCKET_NAME)\n        .getPublicUrl(fileName);\n\n      const publicUrl = urlData.publicUrl;\n\n      logger.info(\n        `StorageService: Image uploaded successfully to ${publicUrl}`\n      );\n\n      return publicUrl;\n    } catch (error: any) {\n      logger.error(\"StorageService: Upload failed:\", error);\n      throw new Error(`Image upload failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Upload multiple images (for batch generation)\n   * @param images - Array of image data objects\n   * @param projectId - Project ID for organizing files\n   * @param contentIds - Array of content IDs corresponding to each image\n   * @returns Array of public URLs\n   */\n  static async uploadMultipleImages(\n    images: Array<{ imageData: string; mimeType: string }>,\n    projectId: string,\n    contentIds: string[]\n  ): Promise<string[]> {\n    logger.info(`StorageService: Uploading ${images.length} images in batch`);\n\n    if (images.length !== contentIds.length) {\n      throw new Error(\"Number of images must match number of content IDs\");\n    }\n\n    const uploadPromises = images.map((image, index) =>\n      this.uploadImage(\n        image.imageData,\n        image.mimeType,\n        projectId,\n        contentIds[index]\n      )\n    );\n\n    try {\n      const urls = await Promise.all(uploadPromises);\n      logger.info(\n        `StorageService: Successfully uploaded ${urls.length} images`\n      );\n      return urls;\n    } catch (error: any) {\n      logger.error(\"StorageService: Batch upload failed:\", error);\n      throw new Error(`Batch image upload failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Delete an image from storage\n   * @param imageUrl - Public URL of the image to delete\n   */\n  static async deleteImage(imageUrl: string): Promise<void> {\n    try {\n      // Extract file path from URL\n      const filePath = this.extractFilePathFromUrl(imageUrl);\n\n      if (!filePath) {\n        throw new Error(\"Invalid image URL\");\n      }\n\n      logger.info(`StorageService: Deleting image at ${filePath}`);\n\n      const { error } = await supabase.storage\n        .from(this.BUCKET_NAME)\n        .remove([filePath]);\n\n      if (error) {\n        logger.error(\"StorageService: Delete error:\", error);\n        throw new Error(`Failed to delete image: ${error.message}`);\n      }\n\n      logger.info(\"StorageService: Image deleted successfully\");\n    } catch (error: any) {\n      logger.error(\"StorageService: Delete failed:\", error);\n      throw new Error(`Image deletion failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Get file extension from MIME type\n   */\n  private static getFileExtension(mimeType: string): string {\n    const extensions: Record<string, string> = {\n      \"image/png\": \"png\",\n      \"image/jpeg\": \"jpg\",\n      \"image/jpg\": \"jpg\",\n      \"image/webp\": \"webp\",\n    };\n\n    return extensions[mimeType] || \"png\";\n  }\n\n  /**\n   * Extract file path from Supabase Storage public URL\n   */\n  private static extractFilePathFromUrl(url: string): string | null {\n    try {\n      // Supabase storage URLs follow pattern:\n      // https://<project>.supabase.co/storage/v1/object/public/<bucket>/<path>\n      const match = url.match(/\\/storage\\/v1\\/object\\/public\\/[^/]+\\/(.+)$/);\n      return match ? match[1] : null;\n    } catch (error) {\n      logger.error(\"StorageService: Error extracting file path:\", error);\n      return null;\n    }\n  }\n\n  /**\n   * Check if an image exists in storage\n   * @param imageUrl - Public URL to check\n   * @returns boolean indicating if image exists\n   */\n  static async imageExists(imageUrl: string): Promise<boolean> {\n    try {\n      const filePath = this.extractFilePathFromUrl(imageUrl);\n\n      if (!filePath) {\n        return false;\n      }\n\n      const { data, error } = await supabase.storage\n        .from(this.BUCKET_NAME)\n        .list(filePath.split(\"/\")[0], {\n          search: filePath.split(\"/\").pop(),\n        });\n\n      return !error && data && data.length > 0;\n    } catch (error) {\n      logger.error(\"StorageService: Error checking image existence:\", error);\n      return false;\n    }\n  }\n\n  /**\n   * Get signed URL for temporary access (if needed for private content)\n   * @param filePath - File path in storage\n   * @param expiresIn - Expiration time in seconds (default: 1 hour)\n   */\n  static async getSignedUrl(\n    filePath: string,\n    expiresIn: number = 3600\n  ): Promise<string> {\n    try {\n      const { data, error } = await supabase.storage\n        .from(this.BUCKET_NAME)\n        .createSignedUrl(filePath, expiresIn);\n\n      if (error) {\n        throw new Error(`Failed to create signed URL: ${error.message}`);\n      }\n\n      return data.signedUrl;\n    } catch (error: any) {\n      logger.error(\"StorageService: Error creating signed URL:\", error);\n      throw new Error(`Signed URL creation failed: ${error.message}`);\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/services/TextGenerationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/services/ThemeAnalysisService.ts","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":136,"column":25,"nodeType":"MemberExpression","endLine":136,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":270,"column":7,"nodeType":"MemberExpression","endLine":270,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * services/ThemeAnalysisService.ts\n *\n * Analyzes themes to extract colors, styles, and brand characteristics.\n */\n\nimport { Theme, ThemeAnalysis, ColorPalette } from \"../types\";\nimport logger from \"../config/logger\";\nimport { colorKeywords, colorMap, styleKeywords } from \"../config/keywords\";\n\nexport class ThemeAnalysisService {\n  /**\n   * Perform a theme analysis and return aggregated metrics.\n   *\n   * @param theme - Theme to analyze (expects `name`, `tags`, `inspirations`).\n   * @returns A `ThemeAnalysis` object containing the derived metrics.\n   */\n  static analyzeTheme(theme: Theme): ThemeAnalysis {\n    logger.info(`ThemeAnalysisService: Analyzing theme \"${theme.name}\"`);\n\n    // 1) Extract a color palette and simple mood from theme tokens\n    const colorPalette = this.extractColorPalette(theme);\n\n    // 2) Score known style categories and pick the top 3\n    const styleScores = this.calculateStyleScores(theme);\n    const dominantStyles = Object.entries(styleScores)\n      .sort((a, b) => b[1] - a[1]) // sort descending by score\n      .filter((a) => a[1] > 0) // filter by score > 0\n      .slice(0, 3) // keep top 3 styles\n      .map(([style]) => style);\n\n    // 3) Determine single-word visual mood (energetic, calm, etc.)\n    const visualMood = this.determineVisualMood(theme);\n\n    // 4) Compute complexity and brand-strength heuristics\n    const complexityScore = this.calculateComplexityScore(theme);\n    const brandStrength = this.calculateBrandStrength(theme);\n\n    // 5) Aggregate a single styleScore for easy ranking: weighted sum\n    //    - prefer explicit style matches, but include complexity & brand\n    const styleScore = Math.round(\n      (styleScores[dominantStyles[0]] || 0) * 0.4 +\n        complexityScore * 0.3 +\n        brandStrength * 0.3\n    );\n\n    // 6) Return the assembled ThemeAnalysis payload\n    return {\n      color_palette: colorPalette,\n      style_score: styleScore,\n      dominant_styles: dominantStyles,\n      visual_mood: visualMood,\n      complexity_score: complexityScore,\n      brand_strength: brandStrength,\n    };\n  }\n\n  /**\n   * Extract a color palette and mood from a Theme.\n   *\n   * @param theme - Theme object containing `name`, `tags`, and `inspirations`.\n   * @returns A `ColorPalette` with `primary`, `secondary`, `accent` arrays and a `mood`.\n   */\n  private static extractColorPalette(theme: Theme): ColorPalette {\n    logger.info(`ThemeAnalysisService: Extracting color palette`);\n\n    const tokens = [...theme.tags, ...theme.inspirations, theme.name]\n      .join(\" \")\n      .toLowerCase();\n\n    const { explicit, adjectives, combined } = this.getColors(tokens);\n    const { primary, secondary, accent } = this.assignPalette(\n      explicit,\n      adjectives,\n      combined\n    );\n\n    const palette: ColorPalette = {\n      primary,\n      secondary,\n      accent,\n      mood: \"neutral\",\n    };\n\n    // Mood inference\n    const warmColors = [\"red\", \"orange\", \"yellow\"];\n    const coolColors = [\"blue\", \"green\", \"purple\", \"teal\"];\n    const energeticKeywords = [\"playful\", \"vibrant\", \"bright\", \"dynamic\"];\n    const calmKeywords = [\"calm\", \"serene\", \"soft\", \"gentle\"];\n    const professionalKeywords = [\"professional\", \"corporate\"];\n\n    const allColors = [\n      ...palette.primary,\n      ...palette.secondary,\n      ...palette.accent,\n    ];\n\n    if (allColors.some((c) => warmColors.includes(c))) {\n      palette.mood = \"energetic\";\n    } else if (allColors.some((c) => coolColors.includes(c))) {\n      palette.mood = \"calm\";\n    }\n    if (energeticKeywords.some((k) => tokens.includes(k)))\n      palette.mood = \"energetic\";\n    if (calmKeywords.some((k) => tokens.includes(k))) palette.mood = \"calm\";\n    if (professionalKeywords.some((k) => tokens.includes(k)))\n      palette.mood = \"professional\";\n\n    logger.info(`ThemeAnalysisService: Extracted color palette: ${palette}`);\n    return palette;\n  }\n\n  /**\n   * Detect explicit color mentions and adjective-derived color suggestions\n   * from a token string.\n   *\n   * - explicit: colors mapped from explicit keywords (via `colorMap`).\n   * - adjectives: colors implied by descriptive words (e.g. \"vibrant\" -> pink, yellow).\n   * - combined: union of explicit + adjective colors with fallback rules\n   *   when no direct matches are found.\n   *\n   * @param tokens - Lowercased combined tokens from theme fields.\n   * @returns An object containing `explicit`, `adjectives`, and `combined` color arrays.\n   */\n  private static getColors(tokens: string): {\n    explicit: string[];\n    adjectives: string[];\n    combined: string[];\n  } {\n    // Explicit color detection\n    const explicit = [\n      ...new Set(\n        Object.keys(colorMap)\n          .sort((a, b) => b.length - a.length)\n          .filter((key) => tokens.includes(key))\n          .map((key) => colorMap[key])\n      ),\n    ];\n\n    // Adjective colors\n    const adjectiveMap: Record<string, string[]> = {\n      colorful: [\"red\", \"blue\", \"yellow\", \"green\", \"orange\"],\n      vibrant: [\"pink\", \"yellow\", \"blue\"],\n      bright: [\"yellow\", \"orange\", \"pink\"],\n      playful: [\"pink\", \"yellow\", \"blue\"],\n      fun: [\"pink\", \"yellow\", \"blue\"],\n      warm: [\"red\", \"orange\", \"yellow\"],\n      cool: [\"blue\", \"green\", \"purple\"],\n      pastel: [\"pink\", \"beige\", \"lavender\"],\n      neon: [\"pink\", \"green\", \"blue\"],\n    };\n\n    const adjectives = [\n      ...new Set(\n        Object.entries(adjectiveMap)\n          .filter(([word]) => tokens.includes(word))\n          .flatMap(([, colors]) => colors)\n      ),\n    ];\n\n    let combined = [...explicit, ...adjectives];\n\n    // Fallback if no colors detected\n    if (combined.length === 0) {\n      if (\n        tokens.includes(\"playful\") ||\n        tokens.includes(\"fun\") ||\n        tokens.includes(\"friendly\")\n      )\n        combined = [\"pink\", \"yellow\", \"blue\"];\n      else if (tokens.includes(\"professional\") || tokens.includes(\"corporate\"))\n        combined = [\"blue\", \"gray\", \"white\"];\n      else if (tokens.includes(\"modern\") || tokens.includes(\"minimal\"))\n        combined = [\"white\", \"black\", \"gray\"];\n      else combined = [\"purple\", \"white\", \"blue\"];\n    }\n\n    combined = [...new Set(combined)];\n\n    return { explicit, adjectives, combined };\n  }\n\n  /**\n   * Assign colors into primary, secondary and accent buckets using a\n   * lightweight weighted strategy.\n   *\n   * Weights:\n   * - explicit mentions => weight 3\n   * - adjective-derived => weight 2\n   * - fallback combined => weight 1 (used only when explicit/adjective lists are empty)\n   *\n   * The method deduplicates colors, keeps the highest weight per color,\n   * sorts by weight and returns the top colors for each bucket.\n   *\n   * @param explicit - Explicitly detected colors.\n   * @param adjectives - Colors suggested by adjectives.\n   * @param combined - Combined/fallback color candidates.\n   * @returns An object with `primary`, `secondary`, and `accent` arrays.\n   */\n  private static assignPalette(\n    explicit: string[],\n    adjectives: string[],\n    combined: string[]\n  ) {\n    const weighted: { color: string; weight: number }[] = [];\n\n    explicit.forEach((c) => weighted.push({ color: c, weight: 3 }));\n    adjectives.forEach((c) => weighted.push({ color: c, weight: 2 }));\n\n    if (explicit.length === 0 && adjectives.length === 0)\n      combined.forEach((c) => weighted.push({ color: c, weight: 1 }));\n\n    const map = new Map<string, number>();\n    weighted.forEach(({ color, weight }) => {\n      map.set(color, Math.max(weight, map.get(color) || 0));\n    });\n\n    const sorted = [...map.entries()]\n      .map(([color, weight]) => ({ color, weight }))\n      .sort((a, b) => b.weight - a.weight);\n\n    const primary = sorted.slice(0, 2).map((x) => x.color);\n    const secondary = sorted.slice(2, 4).map((x) => x.color);\n    const accent = sorted.slice(4, 7).map((x) => x.color);\n\n    return { primary, secondary, accent };\n  }\n\n  /**\n   * Score style relevance for known style categories.\n   *\n   * @param theme - Theme object containing `name`, `tags`, and `inspirations`.\n   * @returns A record mapping style names to numeric scores (0-100).\n   */\n  private static calculateStyleScores(theme: Theme): Record<string, number> {\n    logger.info(\n      `ThemeAnalysisService: Calculating style scores: ${theme.name}`\n    );\n\n    // Combine all theme tokens into a single lowercased string\n    const allTokens = [...theme.tags, ...theme.inspirations, theme.name].join(\n      \" \"\n    );\n    const lowerTokens = allTokens.toLowerCase();\n\n    // Keyword lists for each style category. Presence of a keyword\n    // contributes a fixed increment to that style's score.\n    const styleKeywords: Record<string, string[]> = {\n      modern: [\"modern\", \"contemporary\", \"sleek\", \"clean\", \"minimalist\"],\n      vintage: [\"vintage\", \"retro\", \"classic\", \"nostalgic\"],\n      elegant: [\"elegant\", \"sophisticated\", \"refined\", \"luxurious\"],\n      bold: [\"bold\", \"striking\", \"dramatic\", \"powerful\"],\n      playful: [\"playful\", \"fun\", \"whimsical\", \"creative\"],\n      professional: [\"professional\", \"corporate\", \"business\", \"formal\"],\n      artistic: [\"artistic\", \"creative\", \"expressive\", \"unique\"],\n      minimalist: [\"minimalist\", \"simple\", \"clean\", \"sparse\"],\n    };\n\n    const scores: Record<string, number> = {};\n\n    // For each style, count matching keywords and accumulate a score.\n    // Each match increments by 20 and results are clamped to 100.\n    Object.entries(styleKeywords).forEach(([style, keywords]) => {\n      let score = 0;\n      keywords.forEach((keyword) => {\n        if (lowerTokens.includes(keyword)) {\n          score += 20; // fixed increment per keyword match\n        }\n      });\n      scores[style] = Math.min(score, 100);\n    });\n\n    logger.info(`ThemeAnalysisService: Calculated style scores: ${scores}`);\n    // Return the mapping of style -> score for downstream use\n    return scores;\n  }\n\n  /**\n   * Determine the visual mood of a theme.\n   *\n   * @param theme - Theme object with `name`, `tags`, and `inspirations`.\n   * @returns A short mood string (e.g. 'energetic', 'calm', 'professional').\n   */\n  private static determineVisualMood(theme: Theme): string {\n    logger.info(`ThemeAnalysisService: Anaylising visual mood: ${theme.name}`);\n    // Aggregate all theme tokens into one lowercased string for matching\n    const allTokens = [...theme.tags, ...theme.inspirations, theme.name].join(\n      \" \"\n    );\n    const lowerTokens = allTokens.toLowerCase();\n\n    // Mood keywords grouped by mood label. Count matches per group.\n    const moodKeywords: Record<string, string[]> = {\n      energetic: [\"energetic\", \"dynamic\", \"vibrant\", \"exciting\"],\n      calm: [\"calm\", \"serene\", \"peaceful\", \"tranquil\"],\n      professional: [\"professional\", \"serious\", \"formal\", \"trustworthy\"],\n      friendly: [\"friendly\", \"approachable\", \"warm\", \"welcoming\"],\n      luxurious: [\"luxurious\", \"premium\", \"elegant\", \"sophisticated\"],\n      innovative: [\"innovative\", \"cutting-edge\", \"futuristic\", \"tech\"],\n    };\n\n    // Track highest-scoring mood; default to 'balanced' when none match.\n    let maxScore = 0;\n    let dominantMood = \"balanced\";\n\n    // For each mood, count how many of its keywords appear in the theme.\n    Object.entries(moodKeywords).forEach(([mood, keywords]) => {\n      const score = keywords.filter((k) => lowerTokens.includes(k)).length;\n      // Select mood with the highest match count\n      if (score > maxScore) {\n        maxScore = score;\n        dominantMood = mood;\n      }\n    });\n\n    logger.info(`ThemeAnalysisService: Dominant visual mood: ${dominantMood}`);\n    return dominantMood;\n  }\n\n  /**\n   * Compute a simple complexity score for a Theme.\n   *\n   * Signals used:\n   * - Number of tags (more tags -> higher complexity)\n   * - Number of inspirations (adds nuance)\n   * - Number of words in the theme name (longer names imply complexity)\n   * - Presence of multiple style keywords (indicates stylistic richness)\n   *\n   * @param theme - Theme object to evaluate.\n   * @returns Numeric complexity score between 0 and 100.\n   */\n  private static calculateComplexityScore(theme: Theme): number {\n    logger.info(\n      `ThemeAnalysisService: Calculating complexity scores: ${theme.name}`\n    );\n    let score = 50; // baseline\n\n    // Tags: each tag adds up to 5 points, capped at +20\n    score += Math.min(theme.tags.length * 5, 20);\n\n    // Inspirations: each adds up to 5 points, capped at +15\n    score += Math.min(theme.inspirations.length * 5, 15);\n\n    // Longer theme names suggest richer / more complex concepts\n    const nameWords = theme.name.split(/\\s+/).length;\n    if (nameWords > 2) score += 10;\n\n    // Count presence of style keywords to estimate stylistic richness\n    const allTokens = [...theme.tags, ...theme.inspirations, theme.name].join(\n      \" \"\n    );\n    const styleCount = styleKeywords.filter((s) =>\n      allTokens.toLowerCase().includes(s)\n    ).length;\n\n    if (styleCount > 2) score += 15; // boost when many style keywords found\n\n    // Clamp final score to [0,100]\n    const result = Math.max(0, Math.min(100, score));\n    logger.info(`ThemeAnalysisService: Calculated style score: ${result}`);\n\n    return result;\n  }\n\n  /**\n   * Compute a lightweight brand strength score.\n   *\n   * Signals used:\n   * - Tag count (more tags implies broader brand scope)\n   * - Inspirations count (more inspirations indicates richer references)\n   * - Multi-word name (suggests a descriptive brand name)\n   * - Presence of explicit color words (indicates visual identity)\n   *\n   * @param theme - Theme object to evaluate.\n   * @returns Numeric brand strength score between 0 and 100.\n   */\n  private static calculateBrandStrength(theme: Theme): number {\n    logger.info(\n      `ThemeAnalysisService: Calculated brand strength: ${theme.name}`\n    );\n    // 1) Sanitize tags (remove junk)\n    const cleanedTags = theme.tags\n      .filter((t) => typeof t === \"string\")\n      .map((t) => t.trim().toLowerCase())\n      .filter((t) => t.length > 0 && t.length < 40) // too long = junk\n      .filter((t) => /^[a-z0-9\\-_\\s]+$/i.test(t)); // remove special chars, SQL, symbols\n\n    // 2) Sanitize inspirations\n    const cleanedInsp = theme.inspirations\n      .filter((i) => typeof i === \"string\")\n      .map((i) => i.trim().toLowerCase())\n      .filter((i) => i.length > 0);\n\n    const tokens = [\n      ...cleanedTags,\n      ...cleanedInsp,\n      theme.name.toLowerCase(),\n    ].join(\" \");\n\n    let score = 20; // lower baseline for accuracy\n\n    // TAG QUALITY (not just quantity)\n    const meaningfulTags = cleanedTags.filter(\n      (tag) => !/^\\d+$/.test(tag) && tag.length > 2\n    );\n\n    if (meaningfulTags.length >= 5) score += 25;\n    else if (meaningfulTags.length >= 3) score += 15;\n\n    // Inspirations: reward more inspiration sources (up to +20)\n    if (theme.inspirations.length >= 3) score += 20;\n    else if (theme.inspirations.length >= 1) score += 10;\n\n    // Multi-word names often indicate a richer brand descriptor\n    if (theme.name.split(/\\s+/).length > 1) score += 15;\n\n    // If the theme mentions color words, treat that as a sign of visual identity\n    const allTokens = [...theme.tags, ...theme.inspirations, theme.name].join(\n      \" \"\n    );\n    const hasColors = colorKeywords.some((c) =>\n      allTokens.toLowerCase().includes(c)\n    );\n    if (hasColors) score += 10;\n\n    // STYLE SIGNALS (modern, playful, elegant)\n    if (styleKeywords.some((s) => tokens.includes(s))) score += 10;\n\n    // Negative scoring for REALLY junk input (SQL injection / special chars)\n    const hasJunk =\n      theme.tags.some((t) => typeof t === \"string\" && /['\";<>]/.test(t)) ||\n      theme.inspirations.some(\n        (i) => typeof i === \"string\" && /['\";<>]/.test(i)\n      );\n\n    if (hasJunk) score -= 15;\n\n    // Clamp final score to [0,100]\n    const result = Math.max(0, Math.min(100, score));\n    logger.info(`ThemeAnalysisService: Calculated brand strength: ${result}`);\n\n    return result;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/types/express.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/types/serviceResponse.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/utils/httpHandlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/src/utils/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/authMiddleware.unit.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/client.api.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/clientController.unit.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/content.api.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/contentController.unit.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/embeddingService.unit.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/healthController.unit.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/image.api.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/imageGenerationController.unit.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/imageGenerationService.unit.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/project.api.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/projectController.unit.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/projectThemeService.unit.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/promptEnhancementService.unit.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/qualityScoringService.unit.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/ragService.unit.test.ts","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":125,"column":18,"nodeType":"MemberExpression","endLine":125,"endColumn":22},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":125,"column":25,"nodeType":"MemberExpression","endLine":125,"endColumn":29},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":126,"column":17,"nodeType":"MemberExpression","endLine":126,"endColumn":21},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":126,"column":24,"nodeType":"MemberExpression","endLine":126,"endColumn":28},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":127,"column":17,"nodeType":"MemberExpression","endLine":127,"endColumn":21},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":127,"column":24,"nodeType":"MemberExpression","endLine":127,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * RAGService - Equivalence partitions and test mapping\n *\n * Unit under test:\n * - RAGService.performRAG(projectId, userPrompt, theme)\n *\n * Input partitions (projectId / userPrompt / theme):\n * - P1: missing / undefined projectId (invalid)\n * - P2: empty string projectId (boundary)\n * - P3: whitespace-only projectId (atypical)\n * - P4: normal projectId (valid)\n *\n * - U1: missing/undefined userPrompt (invalid)\n * - U2: empty prompt (boundary)\n * - U3: normal prompt (valid)\n *\n * Content/DB partitions:\n * - R1: ContentModel.listByProject returns populated array (valid)\n * - R2: returns empty array or error -> theme-only fallback (boundary/invalid)\n * - R3: EmbeddingsModel.getByContentId returns embeddings array (valid)\n * - R4: returns empty embedding -> item ignored (invalid)\n *\n * Error partitions:\n * - E1: EmbeddingService.generateQueryEmbedding throws -> returns empty context\n * - E2: generateDocumentEmbedding for theme throws -> empty context\n *\n * Mapping -> tests:\n * - Theme-only fallback: P4 + R2 -> returns theme-only context with avgSimilarity 1.0\n * - Content retrieval: P4 + R1 + R3 -> returns topContents, similarDescriptions includes prompts and themeText, avgSimilarity > 0\n * - Items without embeddings are filtered out (R4)\n * - EmbeddingService errors -> returns empty context (E1/E2)\n * - Invalid projectId / prompt inputs: ensure service handles gracefully (returns empty context)\n */\n\nimport logger from \"../src/config/logger\";\nimport { RAGService } from \"../src/services/RAGService\";\nimport { ContentModel } from \"../src/models/ContentModel\";\nimport { EmbeddingsModel } from \"../src/models/EmbeddingsModel\";\nimport { EmbeddingService } from \"../src/services/EmbeddingService\";\n\njest.mock(\"../src/models/ContentModel\");\njest.mock(\"../src/models/EmbeddingsModel\");\njest.spyOn(logger, \"info\").mockImplementation();\njest.spyOn(logger, \"error\").mockImplementation();\n\ndescribe(\"RAGService\", () => {\n  const originalGenerateQuery = (EmbeddingService as any)\n    .generateQueryEmbedding;\n  const originalGenerateDocument = (EmbeddingService as any)\n    .generateDocumentEmbedding;\n  const originalCosine = (EmbeddingService as any).cosineSimilarity;\n\n  afterEach(() => {\n    jest.clearAllMocks();\n    (EmbeddingService as any).generateQueryEmbedding = originalGenerateQuery;\n    (EmbeddingService as any).generateDocumentEmbedding =\n      originalGenerateDocument;\n    (EmbeddingService as any).cosineSimilarity = originalCosine;\n  });\n\n  // Valid: No project content -> theme-only fallback (R2)\n  it(\"returns theme-only context when no project content exists (boundary - R2)\", async () => {\n    // stub query embedding for prompt\n    (EmbeddingService as any).generateQueryEmbedding = jest\n      .fn()\n      .mockResolvedValue(new Array(3).fill(0.1));\n    // ContentModel returns empty\n    (ContentModel.listByProject as jest.Mock).mockResolvedValue({\n      data: [],\n      error: null,\n    });\n    // theme embedding generation uses document embedding; stub that\n    (EmbeddingService as any).generateDocumentEmbedding = jest\n      .fn()\n      .mockResolvedValue(new Array(3).fill(0.2));\n\n    const theme = {\n      id: \"t1\",\n      name: \"Theme\",\n      tags: [],\n      inspirations: [],\n    } as any;\n    const ctx = await RAGService.performRAG(\"proj1\", \"prompt\", theme);\n\n    expect(ctx.relevantContents).toHaveLength(0);\n    expect(ctx.similarDescriptions).toHaveLength(1);\n    expect(ctx.avgSimilarity).toBe(1.0);\n    expect(EmbeddingService.generateDocumentEmbedding).toHaveBeenCalled();\n  });\n\n  // Valid: content exists with embeddings -> returns topContents (R1 + R3)\n  it(\"returns relevant contents and computes avgSimilarity when embeddings exist (valid - R1/R3)\", async () => {\n    const promptEmbedding = [0.1, 0.2, 0.3];\n    (EmbeddingService as any).generateQueryEmbedding = jest\n      .fn()\n      .mockResolvedValue(promptEmbedding);\n\n    const contents = [\n      { id: \"c1\", prompt: \"p1\" },\n      { id: \"c2\", prompt: \"p2\" },\n    ];\n    (ContentModel.listByProject as jest.Mock).mockResolvedValue({\n      data: contents,\n      error: null,\n    });\n\n    // EmbeddingsModel returns embedding arrays per content\n    (EmbeddingsModel.getByContentId as jest.Mock)\n      .mockResolvedValueOnce({\n        data: [{ embedding: [0.1, 0.2, 0.3] }],\n        error: null,\n      })\n      .mockResolvedValueOnce({\n        data: [{ embedding: [0.0, 0.0, 1.0] }],\n        error: null,\n      });\n\n    // Use real cosine similarity implementation for deterministic result\n    (EmbeddingService as any).cosineSimilarity = jest.fn(\n      (a: number[], b: number[]) => {\n        let dot = 0,\n          ma = 0,\n          mb = 0;\n        for (let i = 0; i < a.length; i++) {\n          dot += a[i] * b[i];\n          ma += a[i] * a[i];\n          mb += b[i] * b[i];\n        }\n        ma = Math.sqrt(ma);\n        mb = Math.sqrt(mb);\n        return ma === 0 || mb === 0 ? 0 : dot / (ma * mb);\n      }\n    );\n\n    (EmbeddingService as any).generateDocumentEmbedding = jest\n      .fn()\n      .mockResolvedValue([0.5, 0.5, 0.5]);\n\n    const theme = { id: \"t2\", name: \"T2\", tags: [], inspirations: [] } as any;\n    const ctx = await RAGService.performRAG(\"proj2\", \"some prompt\", theme);\n\n    expect(ctx.relevantContents.length).toBeGreaterThan(0);\n    expect(ctx.similarDescriptions).toContain(\"p1\");\n    expect(ctx.similarDescriptions).toContain(\"p2\");\n    expect(\n      ctx.similarDescriptions.some(\n        (s) => typeof s === \"string\" && s.startsWith(\"T2:\")\n      )\n    ).toBe(true);\n    expect(ctx.avgSimilarity).toBeGreaterThanOrEqual(0);\n  });\n\n  // Invalid: content items without embeddings are filtered out (R4)\n  it(\"filters out content items without embeddings (invalid - R4)\", async () => {\n    const promptEmbedding = [0.1, 0.2, 0.3];\n    (EmbeddingService as any).generateQueryEmbedding = jest\n      .fn()\n      .mockResolvedValue(promptEmbedding);\n\n    const contents = [\n      { id: \"c1\", prompt: \"p1\" },\n      { id: \"c2\", prompt: \"p2\" },\n    ];\n    (ContentModel.listByProject as jest.Mock).mockResolvedValue({\n      data: contents,\n      error: null,\n    });\n\n    // first has empty embedding, second has a valid one\n    (EmbeddingsModel.getByContentId as jest.Mock)\n      .mockResolvedValueOnce({ data: [], error: null })\n      .mockResolvedValueOnce({\n        data: [{ embedding: [0.1, 0.1, 0.1] }],\n        error: null,\n      });\n\n    (EmbeddingService as any).cosineSimilarity = jest.fn().mockReturnValue(0.5);\n    (EmbeddingService as any).generateDocumentEmbedding = jest\n      .fn()\n      .mockResolvedValue([0.2, 0.2, 0.2]);\n\n    const ctx = await RAGService.performRAG(\"proj3\", \"prompt\", {\n      id: \"t3\",\n      name: \"n\",\n      tags: [],\n      inspirations: [],\n    } as any);\n    // only one content should be in relevantContents\n    expect(ctx.relevantContents).toHaveLength(1);\n  });\n\n  // Error: EmbeddingService.generateQueryEmbedding throws -> returns empty context (E1)\n  it(\"returns empty context when query embedding throws (error - E1)\", async () => {\n    (EmbeddingService as any).generateQueryEmbedding = jest\n      .fn()\n      .mockRejectedValue(new Error(\"bad\"));\n    (ContentModel.listByProject as jest.Mock).mockResolvedValue({\n      data: [],\n      error: null,\n    });\n\n    const ctx = await RAGService.performRAG(\"proj4\", \"prompt\", {\n      id: \"t4\",\n      name: \"n\",\n      tags: [],\n      inspirations: [],\n    } as any);\n    expect(ctx.relevantContents).toHaveLength(0);\n    expect(ctx.avgSimilarity).toBe(0);\n  });\n\n  // Invalid inputs: undefined projectId or prompt should be handled and return empty/empty-ish context\n  it(\"handles undefined inputs gracefully (invalid inputs)\", async () => {\n    (EmbeddingService as any).generateQueryEmbedding = jest\n      .fn()\n      .mockResolvedValue([0.1, 0.1, 0.1]);\n    // stub document embedding used by theme embedding generation to avoid real API calls\n    (EmbeddingService as any).generateDocumentEmbedding = jest\n      .fn()\n      .mockResolvedValue([0.2, 0.2, 0.2]);\n    (ContentModel.listByProject as jest.Mock).mockResolvedValue({\n      data: [],\n      error: null,\n    });\n    const ctx = await RAGService.performRAG(\n      undefined as any,\n      undefined as any,\n      { id: \"t5\", name: \"n\", tags: [], inspirations: [] } as any\n    );\n    // Should return theme-only or empty context depending on internal behavior; assert it doesn't throw and returns object shaped like RAGContext\n    expect(ctx).toHaveProperty(\"relevantContents\");\n    expect(ctx).toHaveProperty(\"themeEmbedding\");\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/server.unit.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/serviceResponse.unit.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/supabaseClient.unit.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/text.api.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/textGenerationController.unit.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/textGenerationService.unit.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/theme.api.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/themeAnalysisService.unit.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/themeController.unit.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/validate.api.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]},{"filePath":"/Users/ismaelolivarez/Documents/github/ASWE/team-ditto/tests/validationController.unit.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/no-extra-semi"}}]}}]}]